#!/usr/bin/env python
"""
Simple example that parametrizes a 2d joint-space path.
"""
import actionlib
from control_msgs.msg import FollowJointTrajectoryAction, FollowJointTrajectoryGoal
from trajectory_msgs.msg import JointTrajectoryPoint
from matplotlib import pyplot as plt
import numpy as np
import rospy
from sensor_msgs.msg import JointState

import traj


def create_joint_trajectory_goal(piecewise_position_function, piecewise_velocity_function,
                                 piecewise_acceleration_function, joint_names, sample_period=0.008):
    # Non-zero start times won't make sense to the controller
    assert piecewise_position_function.boundaries[0] == 0.0
    goal = FollowJointTrajectoryGoal()
    goal.trajectory.header.stamp = rospy.Time.now()
    goal.trajectory.header.frame_id = 'base_link'
    goal.trajectory.joint_names = joint_names

    for t in np.arange(0.0, piecewise_position_function.boundaries[-1], sample_period):
        point = JointTrajectoryPoint()
        point.time_from_start = rospy.Duration(t)
        point.positions = list(piecewise_position_function(t))
        # point.velocities = list(piecewise_velocity_function(t))
        # point.accelerations = list(piecewise_acceleration_function(t))
        goal.trajectory.points.append(point)
    return goal


def joint_state_callback(joint_state_msg):
    global initial_joint_states
    initial_joint_states = joint_state_msg.position


initial_joint_states = None

# Joint limits for a fictional 6DoF arm.

max_velocities = np.deg2rad(np.array([
    150.0,
    150.0,
    200.0,
    300.0,
    300.0,
    600.0,
]))

max_accelerations = np.deg2rad(np.array([
    500.0,
    500.0,
    700.0,
    1100.0,
    1100.0,
    2500.0,
]))

max_jerks = np.deg2rad(np.array([
    4500.0,
    4500.0,
    5000.0,
    8000.0,
    8000.0,
    16000.0,
]))

joint_names = ['joint_1', 'joint_2', 'joint_3', 'joint_4', 'joint_5', 'joint_6']

rospy.init_node('traj_demo')
follow_trajectory_client = actionlib.SimpleActionClient('joint_trajectory_action', FollowJointTrajectoryAction)
follow_trajectory_client.wait_for_server()
rospy.loginfo('Connected to joint trajectory server')

plot_trajectory = rospy.get_param('~plot', False)

joint_states_sub = rospy.Subscriber('joint_states', JointState, joint_state_callback)
while not rospy.is_shutdown() and initial_joint_states is None:
    rospy.sleep(0.1)
rospy.loginfo('Received a joint state message')
start_values = initial_joint_states

# Simple path
path = np.array([initial_joint_states, (1.5, 0.7, 0.3, 0.0, -0.3, 0.0), initial_joint_states,
                 (-1.5, 0.7, 0.3, 0.0, -0.3, 0.0), initial_joint_states])

(trajectory_position_function, trajectory_velocity_function, trajectory_acceleration_function,
 trajectory_jerk_function) = traj.trajectory_for_path(path, max_velocities,
                                                      max_accelerations,
                                                      max_jerks)

goal = create_joint_trajectory_goal(trajectory_position_function, trajectory_velocity_function,
                                    trajectory_acceleration_function, joint_names, sample_period=0.008)

follow_trajectory_client.send_goal(goal)
follow_trajectory_client.wait_for_result()

if plot_trajectory:
    traj.plot.plot_trajectory(plt.figure(), trajectory_position_function, trajectory_velocity_function,
                              trajectory_acceleration_function, trajectory_jerk_function)

    plt.figure()
    traj.plot.plot_2d_path(plt.gca(), trajectory_position_function, 100, label='trajectory points')
    # Plot the waypoints in the original path for comparison.
    plt.plot([q[0] for q in path], [q[1] for q in path], 'bx', label='original waypoints')

    plt.show()
